## Git
### 1. Git
* Git 이란 소스코드를 효과적으로 관리하기 위해 개발된 `분산형 버전 관리 시스템`이다.
### 2. Git 설치
* Git 공식 홈페이지에서(https://git-scm.com) 운영체제에 맞는 Git을 다운로드 후 설치한다.
* Git 설치 후 명령 프롬프트에서 아래의 명령어로 설치된 Git의 버전을 확인한다.
  ```sh
  git --version
  ```
* Sourcetree 공식 홈페이지에서(https://www.sourcetreeapp.com) 운영체제에 맞는 Sourcetree를 다운로드 후 설치한다.
### 3. Git의 주요 용어
#### 3.1. 저장소(Repository)
* 저장소는 파일 / 폴더의 저장 공간으로 파일이 변경 이력 별로 구분되어 저장된다. 
* 원격 서버에서 관리되며 여러 사람이 공유하기 위한 저장소를 `원격 저장소(Remote Repository)`라고 한다.
* 개인 PC에서 관리하는 저장소를 `로컬 저장소(Local Repository)`라고 한다.
#### 3.2. Commit
* 로컬 저장소에 파일이나 폴더의 변경 사항을 기록하는 작업을 `Commit`이라고 한다.
* Git은 Commit을 시간 순으로 저장하며 이전 Commit 상태부터 현재 Commit 상태까지 만들어 보관한다.
* Commit 내용을 통해 변경 이력과 변경 내용을 확인할 수 있다.
#### 3.3. Index(Stage Area)
* Commit 하기 위해 추가하는 파일들이 저장되는 공간을 `Index`라고 한다.
* 사용자 입장에서는 Commit 대기 상태란 뜻으로 `Staging Area`라고 부르기도 하다.
#### 3.4. Branch
* 저장소 내에서 다른 작업에 영향을 받지 않는 독립된 단위의 저장소를 `Branch`라고 한다.
* 즉, Branch는 여러 개발자들이 동시에 다양한 작업을 할 수 있게 만들어 주는 기능이다.
#### 3.5. Checkout
* 현재 Branch를 다른 Branch로 전환하는 것을 `Checkout`이라고 한다.
#### 3.6. Merge
* 특정 브랜치의 작업 내용을 다른 브랜치에 병합하는 것을 `Merge`라고 한다.
#### 3.7. Clone
* 원격 저장소의 내용을 로컬 저장소에 복제하는 것을 `Clone`이라고 한다.
#### 3.8. Push
* 로컬 저장소에서 변경된 이력을 원격 저장소에 업로드하는 것을 `Push`라고 한다. 
#### 3.8. Pull
* 원격 저장소에서 최신 변경 이력을 다운로드하여 로컬 저장소에 적용하는 것을 `Pull`이라고 한다.
### 4. .gitignore 파일
* Git에서 관리하지 않는 파일들의 목록을 작성하는 파일을 `.gitignore 파일`이라고 한다.
* .gitignore 파일은 저장소 최상위에 저장되어야 정상적으로 동작한다.
  ```
  ### Java ###
  # Compiled class file
  *.class

  # Package Files #
  *.jar
  *.war
  *.nar
  *.ear
  *.zip
  *.tar.gz
  *.rar

  ### Windows ###
  # Windows thumbnail cache files
  Thumbs.db

  # Windows Installer files
  *.cab
  *.msi
  *.msix
  *.msm
  *.msp
  ```
## 소프트웨어 공학 개요
### 1. 소프트웨어란?
* 소프트웨어에서 소프트는 '부드럽다'라는 뜻으로 딱딱하고 변경하기 어렵다는 '하드'와 반대되는 개념이다.
* 소프트웨어란 입력된 자료를 처리하여 결과를 출력하는 프로그램과 프로그램의 개발, 운용, 보수에 필요한 자료 일체를 말한다.
### 2. 소프트웨어 공학
* 공학적 원리를 소프트웨어 개발에 적용하는 것이 소프트웨어 공학이다.
* 공학이란 과학과 수학을 기초로 하여 구조나 기계, 시스템 등을 생산하는 데 체계적인 방법을 적용하는 것을 말한다.
### 3. 소프트웨어 개발 작업
#### 3.1. 요구 분석
* 무엇을 개발할지 결정하는 작업이다.
#### 3.2. 설계
* 사용할 수 있는 기술을 이용하여 요구 사항을 어떻게 구현할 것인지 결정하는 작업이다.
#### 3.3. 구현
* 설계한 내용을 구현하는 작업이다.
#### 3.4. 테스트
* 프로그램을 구현한 후 기능이 원하는 대로 작동하는지 테스트하는 작업을 말한다.
#### 3.5. 유지보수
* 개발된 소프트웨어를 완벽해질 때까지 계속 발전시켜나가는 작업을 말한다.
## 요구 분석
### 1. 개요
* 요구 분석은 무엇을 하는 시스템을 개발할지 결정하는 것이다.
### 2. 도메인 분석
* 도메인 분석은 소프트웨어 엔지니어가 개발하려는 분야의 배경지식을 알아가는 과정이다.
* 도메인이란 말은 소프트웨어를 사용할 것으로 예상되는 고객이 일하는 분야의 비즈니스나 기술을 의미한다.
* 도메인 분석으로 얻을 수 있는 장점으로는 빠른 개발, 좋은 시스템, 확장 예견이 있다.
### 3. 요구 추출
* 문제를 이해하기 위해 정보를 수집하고 사용자에게 무엇이 필요한지 찾아내는 것을 요구 추출이라 한다.
#### 3.1. 기능적 요구
* 기능적 요구는 시스템이 무엇을 하는지, 즉 사용자나 다른 시스템을 위해 제공하는 서비스가 무엇인지 기술한 것이다.
#### 3.2. 비기능적 요구
* 비기능적 요구는 소프트웨어를 개발하는 동안 고수해야 할 제약 조건으로, 사용하는 하드웨어의 제약, 소프트웨어 품질의 특성에 대한 수준의 범위를 정해놓은 것이다.
### 4. 요구 문서화
* 문제와 현재의 상태를 파악하고 요구를 도출한 후 해결책을 제시하고 소프트웨어가 어떤 기능을 가져야 하는지 정확히 기술하는 단계를 요구 문서화 또는 명세화라 한다. 
### 5. 요구 검토
* 도출한 요구 사항이 적절한지 검토하고, 수정이 필요하면 다시 요구 추출 단계로 돌아간다.
* 요구 사항을 검토할 때는 관련자들이 모두 참석한 가운데 리뷰 회의를 진행한다.
## 설계
### 1. 개요
* 소프트웨어의 구조 설계는 품질 좋은 소프트웨어 시스템을 개발하기 위한 중요한 단계이다.
* 만약 소프트웨어 구조가 잘 설계되지 않으면 구현, 테스트, 유지보수에 큰 어려움이 뒤따를 것이다.
### 2. 설계의 접근법
#### 2.1. 하향식 설계
* 가장 높은 수준의 구조부터 시작하여 점차 낮은 수준의 구조로 내려오면서 각종 설계 이슈에 관한 의사 결정을 하는 방법이다.
* 소프트웨어 구조와 사용될 데이터베이스의 종류를 먼저 결정한 후 특정 데이터 아이템의 형태와 사용될 개별 알고리즘을 결정하는 것을 예로 들 수 있다.
#### 2.2. 상향식 설계
* 재사용이 가능한 낮은 수준의 기능을 먼저 정한 다음, 높은 수준의 구조를 만들기 위해 이것들을 어떻게 배치할지 결정한다.
### 3. 설계의 종류
* 아키텍처 설계
* 클래스 설계
* 사용자 인터페이스 설계
* 데이터베이스 설계
* 알고리즘 설계
* 프로토콜 설계
### 4. 설계안 결정
#### 4.1. 목표와 우선순위 결정
* 본격적인 설계를 시작하기 전에 여러 가지 품질 측면에 대해 목표와 우선순위를 수립해야 한다.
* 목표와 우선순위를 정할 때 고려할 품질은 메모리 효율성, CPU 효율성, 유지보수성, 이식성, 사용성이다.
#### 4.2. 비용 효과 분석
* 설계할 때 고려해야 할 중요한 점은 비용을 줄이고 효과를 높이는 방법을 찾는 것이다.
* 새로운 기능이나 설계안에 대한 비용을 추정하기 위해 다음과 같은 요소를 고려한다.
  * 소프트웨어 엔지니어링 작업에 드는 추가 비용
  * 특정 개발 기술에 드는 추가 비용
  * 사용자 및 제품 지원 인력에 드는 추가 비용
  * 소프트웨어 엔지니어링 작업 시 절약 시간
  * 매출 향상이나 사용자의 금전적 이익 
## UML(Unified Modeling Language)
### 1. UML(Unified Modeling Language)
* UML은 소프트웨어를 시각적으로 모델링 하기 위해 사용한다.
* UML은 소프트웨어를 모델링 하는 표준 그래픽 언어로 심벌과 그림을 사용하여 나타낼 수 있다.
### 2 UML의 목적
* UML의 목적은 소프트웨어 개발에 도움을 주는 것이다.
* 개발 과정에 여러 가지 다이어그램으로 설계하면 구조가 좋아지고 개발자들 간의 의사 교환이 쉬어진다.
### 3. UML 다이어그램의 종류
#### 3.1. 사용 사례 다이어그램
* 액터와 사용 사례를 통해 시스템의 기능을 모델링 하는 데 사용한다.
* 개발하려는 시스템의 기능적 요구 또는 업무 프로세스의 개관을 나타낸다.
#### 3.2. 시퀀스 다이어그램
* 객체 사이의 메시지 교환을 시간의 흐름에 따라 나타낸 것이다.
* 즉, 사용 사례로 표시된 업무 프로세스에 대해 시스템 안의 존재하는 객체가 어떤 식으로 개입하여 상호작용하는지를 나타낸다.
#### 3.3. 클래스 다이어그램 
* 객체지향 시스템의 가장 근간이 되는 다이어그램으로 시스템의 정적인 구조를 나타낸다.
* 또한 도메인(문제 영역)의 개념과 그것들 사이의 관계를 표시한다.
#### 3.4. 패키지 다이어그램 
* 관련된 클래스를 패키지로 그루핑하여 복잡한 시스템을 조직화하는 데 사용한다.
#### 3.5. 상태 다이어그램
* 외부 자극에 대한 시스템의 동적 상태 변화를 나타낸다.
* 외부 이벤트에 대해 민감하게 상태를 변화시키는 객체를 모델링 한다.
#### 3.6. 액티비티 다이어그램
* 시스템의 내부 프로세스를 단계별 작업 흐름 형태로 모델링 한다.
* 시스템의 동적 특징을 나타낸다.
#### 3.7. 배치 다이어그램
* 노드, 컴포넌트, 커넥터 등 시스템의 물리적 자원 배치를 나타낸다.
## 디자인 패턴
### 1. 개요
* 자주 반복되는 설계 유형을 디자인 패턴이라 한다.
* 디자인 패턴은 체계적으로 문서화하여 범용적으로 사용할 수 있도록 정리한 것이다.
### 2. 기본 패턴
#### 2.1. 개념 실체 패턴(Abstraction Occurrence Pattern)
* 각 객체의 공통 정보를 공유할 때 사용한다.
* 실체는 공통된 정보를 가진 멤버들의 모임이고, 개념은 공유하는 정보를 담는 클래스이다.
#### 2.2. 플레이어 역할 패턴 (Player Role Pattern)
* 하나의 클래스에 다양한 역할을 표현하고 싶을 때 사용한다.
#### 2.3. 위임 패턴(Delegation Pattern)
* 다른 클래스가 가진 특정 오퍼레이션을 활용하여 책임을 위임하고 싶을 때 사용한다.
#### 2.4. 계층 구조 패턴
* 계층 관계를 가진 객체들을 묶어 동일한 처리를 하고 싶을 때 사용한다.
### 3. 생성 패턴
#### 3.1. 팩토리 패턴(Factory Pattern)
* 생성자가 제공할 수 없는 유연성을 가지고 실행 시간에 객체를 생성한다.
* 객체들을 리턴하는 메소드를 사용하여 필요한 객체를 생성한다.
#### 3.2. 추상 팩토리 패턴(Abstract Factory Pattern)
* 객체의 구체적인 클래스를 명시하지 않고서 그 객체와 관계되거나 의존하는 그룹을 생성하는 인터페이스를 제공한다.
* 팩토리 패턴과 유사하지만 팩토리 패턴과 달리 객체 그룹을 추상화한다.
#### 3.3. 프로토타입 패턴(Prototype Pattern)
* 클래스를 인스턴스로 만들어놓은 후 그 객체를 사용할 때 다시 생성하지 않고 복사해서 사용하는 패턴이다.
* 결국 프로토타입 패턴은 새로운 인스턴스가 필요할 때마다 프로토타입의 클론(복사본)을 만드는 것이다.
#### 3.4. 싱글턴 패턴(Singleton Pattern)
* 객체를 하나만 생성하는 클래스를 정의한다.
* 어떻게 하면 시스템 안에 객체가 유일하게 존재하게 하는가라는 문제를 해결해준다.
### 4. 구조 패턴
#### 4.1. 컴포지트 패턴(Composite Pattern)
* 시스템을 구축하다 보면 객체의 집합을 다루어야 할 때가 많다. 
* 패턴은 집합 속에 포함될 객체와 집합을 가지고 있는 객체 모두가 자기 자신과 동일한 메소드와 데이터를 가질 수 있게 해준다. 
#### 4.2. 데코레이터 패턴(Decorator Pattern)
* 프로그램이 실행될 때 객체에 어떤 기능을 추가해야 하는 경우가 있다.
* 데코레이터 패턴은 객체 생성 없이 개별 객체에 데코레이터를 이용하여 동작을 첨부할 수 있다.
#### 4.3. 어댑터 패턴(Adapter Pattern)
* 어댑터 패턴은 이미 개발된 클래스의 인터페이스를 다른 클래스의 요구에 맞게 변환해주는 것이다.
* 어댑터는 서로 호환성이 없는 인터페이스들이 같이 동작할 수 있도록 도와주는 변환기이다.
#### 4.4. 퍼사드 패턴(Facade Pattern)
* 서브시스템의 내부가 복잡하여 클라이언트 코드를 사용하기 힘들 때 사용한다.
* 복잡한 것을 단순하게 보여주고, 내부에서 동작하는 클래스들의 관계나 사용법을 몰라도 사용할 수 있도록 해준다.
#### 4.5. 프록시 패턴(Proxy Pattern)
* 프록시 패턴은 복잡하거나 생성하는 데 시간이 오래 걸리는 객체를 좀 더 간단한 객체로 표현하기 위해 그 객체가 필요할 때까지 생성을 보류해 준다.
* 프록시는 컴퓨터 리소스나 시간을 많이 소모하는 객체를 인스턴스화할 때 객체가 실제로 필요할 때까지 생성을 지연시키는 역할을 한다.
### 5. 행위 패턴
#### 5.1. 옵서버 패턴(Observer Pattern)
* 옵서버 패턴은 특정 데이터나 객체를 모니터링하고 있다가 변화가 발생하면 시스템이 이를 알리고 연관된 객체들이 변화에 대응하는 작업을 실행하도록 만들어준다.
#### 5.2. 중재자 패턴(Mediator Pattern)
* 시스템을 이루는 객체들 사이의 밀접한 연관 관계를 효육적으로 처리해주는 패턴이다.
* 객체 내부의 변화나 특정 작업의 실행이 다른 객체에 영향을 미칠 때 중재자 객체가 중간에서 서로 간의 변화나 메시지를 조정하여 시스템이 원활하게 작동하도록 해준다.
#### 5.3. 책임 체인 패턴(Chain of Responsibility Pattern)
* 사용자가 원하는 작업을 어떤 객체에게 시킬지 모를 때 그 작업을 다룰 만한 객체들의 집합에 던져버리는 패턴이다.
#### 5.4. 커맨드 패턴(Command Pattern)
* 작업을 처리할 객체 집단에서 처리를 담당할 객체를 직접 지정한 후 그 객체를 처리 박스에 요청하여 처리하는 패턴이다.
#### 5.5. 상태 패턴(State Pattern)
* 상태를 객체로 만들고 상태에 관련된 모든 행위를 하나의 객체로 모으는 패턴이다.
## 구현
### 1. 구현이란?
* 설계 명세를 토대로 분리하여 구현할 수 있는 작은 단위별로 프로그래밍하는 것을 말한다.
* 사용자의 요구를 만족시키는 프로그램을 만들려면 상세 설계나 사용자 지침서에 기술된 것과 일치하도록 코딩을 해야 한다.
### 2. 코딩 표준
* 코딩 표준은 코드를 읽기 쉽고 이해하기 쉽게 작성하기 위한 규칙과 가이드라인을 제공한다.
* 코딩 스타일을 표준화하면 개발 및 유지 보수 비용과 시간이 줄어들어 소프트웨어의 생산성과 품질을 높일 수 있다.
* 대부분의 개발 팀은 프로그래머가 정해진 코딩 표준을 따르도록 교육하고 있다.
* 참고 URL
  * https://google.github.io/styleguide/javaguide.html
  * https://naver.github.io/hackday-conventions-java/
  * https://www.oracle.com/java/technologies/javase/codeconventions-introduction.html
### 3. 리팩토링
* 리팩토링이란 기능의 변경 없이 코드의 디자인을 개선하는 것으로, 문제가 될 만한 부분을 찾아내어 수정하고 재구조화하는 작업이다.
* 리팩토링을 하면 코드를 쉽게 이해할 수 있을 뿐만 아니라 확장 및 재사용할 수 있다.
* 더 읽기 쉽게 하고, 결합을 낮추며, 응집을 높여서 코드를 쉽게 변경할 수 있도록 하는 것이다.
#### 3.1. 리팩토링 작업 과정
* 작은 변경을 가한다.
* 모두 잘 작동된다는 것을 확인하기 위해 테스트한다.
* 모두 잘 작동된다면 다음 리팩토링으로 넘어간다.
* 작동되지 않으면 문제를 수정하거나 원상 복구하여 시스템이 작동되도록 유지한다.
#### 3.2. 코드 스멜
* 설계를 수정하기 어렵게 만드는 코드를 코드 스멜이라 한다.
  * 중복 코드
  * 긴 메소드
  * 큰 클래스
  * 많은 케이스를 가진 case 문장
  * 긴 메소드 호출
  * 지나친 널 객체 체크
  * 유사 데이터의 중복
  * 데이터 클래스(메소드는 거의 없고 속성만 많은 클래스)
  * 캡슐화되지 않은 필드
* 이러한 코드 스멜을 줄이기 위한 방법은 아래와 같다.
  * 클래스 추출
  * 메소드 추출
  * 서브 클래스 추출
  * 템플릿 메소드 형성
  * 메소드 이동
